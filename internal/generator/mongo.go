package generator

import (
	"bytes"
	"embed"
	"fmt"
	"text/template"

	"github.com/zeek-r/goapigen/internal/parser"
)

// TestField represents a test value for a field in tests
type TestField struct {
	Name      string
	TestValue string
}

// RepositoryTemplateData contains data for the repository template
type RepositoryTemplateData struct {
	SchemaName     string
	VarName        string
	PluralVarName  string
	PackageName    string
	RepoPackage    string
	ImportPath     string
	CollectionName string
	HasCreateOp    bool
	HasGetOp       bool
	HasListOp      bool
	HasUpdateOp    bool
	HasDeleteOp    bool
	HasCreatedAt   bool
	HasUpdatedAt   bool
	TestFields     []TestField
}

// MongoGenerator generates MongoDB repository implementations for API schemas
type MongoGenerator struct {
	parser      *parser.OpenAPIParser
	packageName string
	repoPackage string
	importPath  string
	templateFS  embed.FS
	typeGen     *TypeGenerator
	templates   *template.Template
}

// NewMongoGenerator creates a new MongoDB repository generator
func NewMongoGenerator(parser *parser.OpenAPIParser, packageName string, repoPackage string, importPath string, templateFS embed.FS) (*MongoGenerator, error) {
	// Parse templates
	tmpl, err := template.ParseFS(templateFS, "templates/mongo/repository.go.tmpl", "templates/mongo/repository_test.go.tmpl")
	if err != nil {
		return nil, fmt.Errorf("failed to parse templates: %w", err)
	}

	return &MongoGenerator{
		parser:      parser,
		packageName: packageName,
		repoPackage: repoPackage,
		importPath:  importPath,
		templateFS:  templateFS,
		typeGen:     NewTypeGenerator(parser, packageName, templateFS),
		templates:   tmpl,
	}, nil
}

// GenerateRepository generates a MongoDB repository for a schema
func (g *MongoGenerator) GenerateRepository(schemaName string) (string, error) {
	// Generate the template data
	data, err := g.prepareTemplateData(schemaName)
	if err != nil {
		return "", err
	}

	// Render the template
	var buf bytes.Buffer
	if err := g.templates.ExecuteTemplate(&buf, "repository.go.tmpl", data); err != nil {
		return "", fmt.Errorf("failed to render repository template: %w", err)
	}

	return buf.String(), nil
}

// GenerateRepositoryTests generates test files for a repository
func (g *MongoGenerator) GenerateRepositoryTests(schemaName string) (string, error) {
	// Generate the template data
	data, err := g.prepareTemplateData(schemaName)
	if err != nil {
		return "", err
	}

	// Render the template
	var buf bytes.Buffer
	if err := g.templates.ExecuteTemplate(&buf, "repository_test.go.tmpl", data); err != nil {
		return "", fmt.Errorf("failed to render repository test template: %w", err)
	}

	return buf.String(), nil
}

// prepareTemplateData prepares data for the templates
func (g *MongoGenerator) prepareTemplateData(schemaName string) (RepositoryTemplateData, error) {
	// Check if schema exists
	schema, exists := g.parser.GetSchemaByName(schemaName)
	if !exists {
		return RepositoryTemplateData{}, fmt.Errorf("schema %s not found", schemaName)
	}

	// Get CRUD operations for this schema
	crudOps := g.parser.GetCrudOperationsForSchema(schemaName)

	// Prepare test fields with default test values
	testFields := []TestField{}

	for propName, propRef := range schema.Properties {
		if propRef == nil || propRef.Value == nil {
			continue
		}

		// Skip ID field as it's handled separately in tests
		if propName == "id" || propName == "ID" {
			continue
		}

		// Skip timestamp fields that are autogenerated
		if propName == "created_at" || propName == "createdAt" ||
			propName == "updated_at" || propName == "updatedAt" {
			continue
		}

		fieldName := ToGoFieldName(propName)
		testValue := GetTestValueForProperty(propRef.Value)

		testFields = append(testFields, TestField{
			Name:      fieldName,
			TestValue: testValue,
		})
	}

	// Prepare template data
	data := RepositoryTemplateData{
		SchemaName:     schemaName,
		VarName:        ToCamelCase(schemaName),
		PluralVarName:  ToCamelCase(schemaName) + "s",
		PackageName:    g.packageName,
		RepoPackage:    g.repoPackage,
		ImportPath:     g.importPath,
		CollectionName: ToSnakeCase(schemaName) + "s",
		HasCreateOp:    false,
		HasGetOp:       false,
		HasListOp:      false,
		HasUpdateOp:    false,
		HasDeleteOp:    false,
		HasCreatedAt:   false,
		HasUpdatedAt:   false,
		TestFields:     testFields,
	}

	// Set operation flags based on OpenAPI spec
	if _, ok := crudOps["create"]; ok {
		data.HasCreateOp = true
	}
	if _, ok := crudOps["get"]; ok {
		data.HasGetOp = true
	}
	if _, ok := crudOps["list"]; ok {
		data.HasListOp = true
	}
	if _, ok := crudOps["update"]; ok {
		data.HasUpdateOp = true
	}
	if _, ok := crudOps["delete"]; ok {
		data.HasDeleteOp = true
	}

	// Check for timestamp fields
	for propName, propRef := range schema.Properties {
		if propRef != nil && propRef.Value != nil {
			if propName == "created_at" || propName == "createdAt" {
				data.HasCreatedAt = true
			}
			if propName == "updated_at" || propName == "updatedAt" {
				data.HasUpdatedAt = true
			}
		}
	}

	return data, nil
}
